# 作为行为组件的脚本
unity 中，脚本可以定义组件的行为方式，以此来进行操作的响应等其他行为。


# 约定和语法
和 python 相比，主要有以下区别：
1. 代码库用 `{}` 框起来。
2. 条件表达式需要用 `()` 表示。
3. 语句结尾需要有 `;`。

# 循环
包含四种：
```c# 
// ForLoop
for(int i = 0; i < 100; i++)
{
    Debug.Log("Creating enemy number: " + i);
}

// WhileLoop
while(0)
{
    Debug.Log ("I've washed a cup!");
    cupsInTheSink--;
}

// DoWhileLoop
do
{
    print ("Hello World");
    
}while(true);

// ForeachLoop
foreach(string item in strings)
{
    print(item)
}
```

# `Awake` 和 `Start` 函数
在Unity中，`Awake()`和`Start()`是 MonoBehaviour 类中两个非常重要的生命周期方法，用于控制游戏对象的初始化过程和执行初期设置。它们的主要用途和区别如下：

### Awake()
- **调用时机**：`Awake()`方法在脚本实例被创建并且初始化完成后立即调用，无论该脚本所挂载的游戏对象是否处于激活状态（即`enabled`属性是否为真）。这意味着即使游戏对象刚开始是不可见或未激活的，其上的脚本的`Awake()`方法也会执行。
- **用途**：通常用于执行一次性初始化设置，比如设置游戏状态、初始化变量、配置管理器类、或者对其他单例对象的引用进行设置。由于`Awake()`保证在任何`Start()`方法之前执行，它适合用于需要最早进行的设置或依赖关系的建立。

### Start()
- **调用时机**：`Start()`方法在`Awake()`之后，并且在第一个`Update()`方法调用之前执行，但仅当该脚本所挂载的游戏对象是激活状态（`enabled`为真）时才会执行。如果游戏对象在`Awake()`之后被禁用，则`Start()`不会被调用，直到游戏对象被再次启用。
- **用途**：适合执行那些不需要最早初始化但仍然是一次性设置的任务，例如初始化那些依赖于其他组件已经初始化完毕的对象，或者是进行具体的场景布置、游戏逻辑的初始状态设定等。

### 总结
- `Awake()`更早执行，适合做最基础的设置和初始化，特别是当这些设置会影响到其他脚本或组件的初始化时。
- `Start()`在`Awake()`之后执行，适合执行大多数游戏逻辑的初始化，但需要游戏对象是激活的。
- 两者都只在脚本生命周期中调用一次，除非游戏对象被销毁后重新实例化。

在实际开发中，选择使用`Awake()`还是`Start()`取决于具体需求，比如初始化顺序的依赖关系或是否需要考虑游戏对象的激活状态。

# `Update` 和 `FixedUpdate`
在Unity中，`Update()`和`FixedUpdate()`是MonoBehaviour类中用于控制游戏逻辑更新的两个重要方法，它们在游戏循环中有各自特定的用途和调用时机：

### Update()
- **调用时机**：`Update()`方法在每一帧渲染时被调用，执行频率与游戏的帧率（FPS）直接相关。这意味着如果游戏运行得更快（高FPS），`Update()`会被更频繁地调用；反之，如果游戏运行得慢（低FPS），调用频率也会降低。因此，`Update()`适合执行与时间无关或对实时性要求不高的游戏逻辑，如处理用户输入、游戏状态更新、UI更新等。
  
- **用途**：主要用于处理大部分游戏逻辑，包括但不限于响应玩家输入、更新动画状态、改变游戏状态等。由于它与帧率挂钩，游戏在不同性能的设备上可能会有不同表现，因此不适合处理需要精确时间间隔的物理模拟。

### FixedUpdate()
- **调用时机**：与`Update()`不同，`FixedUpdate()`是在固定的时间间隔（默认大约每秒50次，但可调整）被调用，不受游戏帧率波动的影响。这意味着无论游戏运行得多快或多慢，`FixedUpdate()`的调用间隔保持相对稳定，这对于物理模拟和需要精确时间步长的计算至关重要。
  
- **用途**：主要用于物理模拟和与Rigidbody相关的操作，例如移动、旋转、碰撞检测等。因为物理计算需要在每一段时间内保持一致性以确保物理行为的准确性和稳定性，所以放在`FixedUpdate()`中执行可以避免因帧率波动导致的物理效果不一致问题。

### 总结
- 使用`Update()`处理不严格依赖时间间隔且对实时性要求不高的游戏逻辑。
- 使用`FixedUpdate()`处理物理模拟和需要时间精确控制的逻辑，确保这些操作的稳定性和可预测性，尤其是在不同性能的硬件上。

理解这两个方法的区别和正确使用它们，对于开发出性能稳定、物理行为一致的游戏至关重要。

# 矢量数学
使用左手系
![alt text](img\LeftHandRule.png)

向量点乘运算：可用于判定用于判定两个向量的夹角。点积为0，表示向量垂直。

向量叉乘运算：可用于计算垂直两个向量平面的向量。可用于计算坦克炮塔的旋转轴。
![alt text](img\CrossRule.png)
叉乘的左手法则

```C#
Vector3.magnitude   // 计算模长
Vector3.Dot(VectorA,VectorB)    // 计算点乘
Vector3.Cross(VectorA,VectorB)    // 计算叉乘
```

# 启用和禁用组件

在Unity中，启用（enable）和禁用（disable）组件是一种常见的机制，用于在游戏运行时动态地控制 GameObject 上特定功能的开关，而无需销毁或重新创建组件。这种机制有许多用途，具体包括但不限于以下几点：

1. **性能优化**：禁用不需要的组件可以减少CPU和GPU的计算负担，特别是在那些不再需要交互或暂时远离玩家视野的对象上。例如，当角色远离某个区域时，可以禁用该区域的灯光或粒子系统以节省资源。

2. **游戏逻辑控制**：通过启用或禁用组件，可以实现游戏内的各种逻辑。比如，当玩家进入一个新的关卡时，可以通过禁用旧关卡的敌人和障碍物组件，同时启用新关卡的相关组件来切换场景内容。

3. **临时禁用功能**：在调试过程中，如果怀疑某个组件有问题，可以临时禁用它来排除故障，而不必从GameObject上移除，便于快速恢复测试。

4. **UI管理**：在UI设计中，经常需要根据游戏状态显示或隐藏界面元素，通过启用或禁用UI组件（如按钮、文本、图像）来实现这一需求。

5. **物理模拟控制**：对于物理组件（如Rigidbody、Collider），启用和禁用可以控制对象是否参与物理模拟。例如，当角色死亡后禁用其Rigidbody可以让角色“冻结”在原地，不再受物理影响。

6. **节省内存**：虽然禁用组件不会立即回收内存，但减少了组件上的更新和渲染调用，间接帮助了内存管理，特别是在内存紧张的移动平台上。

```C#
using UnityEngine;
using System.Collections;

public class EnableComponents : MonoBehaviour
{
    private Light myLight;
    
    
    void Start ()
    {
        myLight = GetComponent<Light>();
    }
    
    
    void Update ()
    {
        if(Input.GetKeyUp(KeyCode.Space))
        {
            myLight.enabled = !myLight.enabled; // 通过脚本设置组件的可用状态
        }
    }
}
```

# 激活游戏对象
在Unity中，**激活游戏对象（Activating a GameObject）**意味着使游戏对象变为可交互和可见的状态，使其参与到游戏场景中来。游戏对象（GameObject）是Unity中所有可放置在场景中的实体的基本容器，包括从简单的几何体到复杂的角色、摄像机、灯光等。

**激活游戏对象的用处包括但不限于：**

1. **控制游戏流程**：通过激活或禁用游戏对象，可以控制游戏的不同阶段或关卡的进度。例如，在完成一个谜题后，可以激活通往下一区域的门。

2. **性能优化**：在不需显示或处理某些对象时将其禁用，可以减少CPU和GPU的计算负担，提高游戏运行效率。这对于移动平台或资源受限的环境尤为重要。

3. **对象池**：在需要频繁创建和销毁大量相似对象（如子弹、敌人）的场景中，可以通过预先创建好一批对象并根据需要激活或禁用，来避免频繁的内存分配和释放，提升性能。

4. **UI管理**：在用户界面（UI）设计中，根据游戏状态显示或隐藏不同的UI元素，也是通过激活或禁用来实现的。

5. **动画和特效控制**：在特定时刻激活带有动画或粒子系统的对象，以展示特效或进行剧情推进。

6. **调试与测试**：在开发过程中，可以临时禁用某些游戏对象以便专注于测试或调试其他部分，而无需从场景中移除它们。

**激活与禁用游戏对象的方法**通常通过调用`GameObject.SetActive(bool)`方法来实现，其中传入`true`表示激活，`false`表示禁用。例如：

```csharp
gameObject.SetActive(true); // 激活游戏对象
gameObject.SetActive(false); // 禁用游戏对象
```

通过这种方式，开发者能够灵活地管理场景中的元素，进而控制游戏的复杂交互和视觉呈现。

## 和启用禁用组件的区别
在Unity中，**激活游戏对象**和**启用/禁用组件**是两个相关但有所区别的概念，它们分别影响游戏对象的不同层面。

**激活游戏对象（`SetActive`）**：
- 影响整个游戏对象（GameObject）及其所有附加的组件。当一个游戏对象被禁用（`SetActive(false)`）时，整个对象及其上的所有组件都不再更新、渲染或接收任何输入事件。这相当于游戏对象及其所有子对象在场景中完全消失，但仍然存在于场景的层次结构中，并且可以随时再次激活。
- 使用场景：当你想要整体上隐藏或显示一个对象及其所有功能时，比如玩家角色死亡后隐藏角色以及其相关的动画、碰撞器等。

**启用/禁用组件（`enabled`）**：
- 只影响单个组件，而不影响游戏对象上的其他组件。这意味着你可以独立控制一个游戏对象上的某个特定功能是否生效。例如，你可以禁用一个游戏对象上的`Rigidbody`组件以停止物理模拟，但保持其`Animator`组件继续播放动画。
- 使用场景：当你想要精细控制游戏对象的功能，比如暂时关闭某个敌人的感知能力（禁用其脚本组件）而不移除它的视觉表现或碰撞检测时。

**总结**：
- 激活游戏对象是更全局的操作，适用于需要整体控制对象存在感的场景。
- 启用/禁用组件提供了更细致的控制，适合对游戏对象内部功能的精确调整，而不影响其他功能。

开发者可以根据具体需求选择使用哪种方法来优化性能、管理游戏逻辑或实现特定的游戏机制。